基本概念
https://zhuanlan.zhihu.com/p/463182588
▭和⬭：执行结点(execution node)：行为树的叶子结点，可以是▭动作结点(action node)或⬭条件结点(condition node)。
对于⬭条件结点(condition node)会在一次tick后立马返回成功或失败的状态信息。
对于▭动作结点(action node)则可以跨越多个tick执行，直到到达它的终结状态。
一般来说，条件结点用于简单的判断(比如钳子是否打开?)，动作结点用于表示复杂的行为(比如打开房门)。

▢和◊：控制结点(control node)：
控制结点是行为树的内部结点，它们定义了遍历其孩子结点的方式。控制结点的孩子可以是执行结点，也可以是控制结点。
→顺序(Sequence)，？备选(Fallback)，⇉并行(Parallel)这3种类型的控制结点可以有任意数量的孩子结点，
它们的区别在于对其孩子结点的处理方式。
而◊装饰(Decorator)结点只能有一个孩子结点，用来对孩子结点的行为进行自定义修改。

→顺序结点：按顺序执行孩子结点直到其中一个孩子结点返回失败状态或所有孩子结点返回成功状态。
?备选结点：按顺序执行孩子结点直到其中一个孩子结点返回成功状态或所有孩子结点返回失败状态。一般用来实现角色的备选行为。
⇉并行结点：“并行执行”所有孩子结点。直到至少M个孩子(M的值在1到N[并行节点下孩子节点总数]之间)结点返回成功状态或所有孩子结点返回失败状态。
◊装饰结点：以自定义的方式修改孩子结点的行为。比如Invert类型的装饰结点，可以反转其孩子结点返回的状态信息。为了方便他人理解，应该尽可能使用比较常见的装饰结点。

装饰器(decorator)和黑板(blackboard)
例子：
装饰器：搜寻多个点，相较于每增加一个搜寻地点就复制一份完全相同的子树，我们可以定义一个规则为Repeat的装饰器结点，用来重复执行它的孩子结点，完成搜寻多个地点。
使用一个队列存储所有待搜寻地点，每次迭代从队列中取出一个地点进行搜寻，当队列为空时，所有地点都被搜寻完毕。
黑板：为了存储可以被多个结点访问的共享信息(比如上面提到的存储有所有待搜寻地点的队列)，我们引入黑板(blackboard)的概念。黑板是一块可以被结点读写的公共存储区。

行为树更好还是状态机更好需要看具体要解决的问题，
有限状态机更方便管理高优先级的操作行为(比如机器人处于正常状态还是充电状态)，行为树更适合定义复杂的行为，比如处理错误恢复等等。
实践中，混合使用两者可能会是更好的选择。


常用的设计规则
显式成功条件(explicit success condition)：先检测机器人是否已经在A处，如果在就不执行去A处的动作，直接返回成功状态
