https://cplusplus.com/reference/atomic/ c++库文档网站
https://learn.microsoft.com/en-us/cpp/standard-library/unique-ptr-class?view=msvc-170 MSDNc++库函数文档

[main的参数]
int argc: 于参数计数 输入的程序路径及名称也是一个参数所以参数最少为1
char **argv or: char *argv[] ：一个指向字符串数组的指针，差不多等价赋值方法不同
                               argv[0]指向输入的程序路径及名称 argv[n] 指向第n个参数字符串
                               char **argv赋值： char **arg = (char**)malloc(3*sizeof(char*));
                               都可以通过arg[n]来访问
                               
[std::unique_lock和std::lock_guard]                
std::unique_lock比std::lock_guard更灵活，这种灵活性主要体现在以下几点：
■ lock_guard在构造时或者构造前（std::adopt_lock）就已经获取互斥锁，并且在作用域内保持获取锁的状态，直到作用域结束；
而unique_lock在构造时或者构造后（std::defer_lock）获取锁，在作用域范围内可以手动获取锁和释放锁，作用域结束时如果已经获取锁则自动释放锁。
■ lock_guard锁的持有只能在lock_guard对象的作用域范围内，作用域范围之外锁被释放，
而unique_lock对象支持移动操作，可以将unique_lock对象通过函数返回值返回，这样锁就转移到外部unique_lock对象中，延长锁的持有时间。

[std::move()] 
将一个左值转换成右值,并避免内存拷贝。
避免内存拷贝依赖于被std::move转换的对象的具体实现，std::move只是将对象以右值的形式告诉接受者，这个对象的赋值操作可以直接使用其内存地址，而不是创建新内存拷贝数据。
                             
[std::atomic<bool> = std::atomic_bool]
最基本的原子整数类型是std::atomic，（可以使用预定义的别名std::atomic_bool），这是一个比std::atomic_flag功能更全的布尔标志，并且可以使用非原子的bool来赋值和初始化。
std::atomic_bool::exchange:用val替换包含的值，并返回之前的值(设置锁)。

[std::make_unique<'type'>('parm')]
尽量使用std::make_unique和std::make_shared而不直接使用new
std::make_shared是c++11的一部分，std::make_unique不是。它是在c++14里加入标准库的
make函数用来把一个任意参数的集合完美转移给一个构造函数从而生成动态分配内存的对象，并返回一个指向那个对象的灵巧指针。

[std::weak_ptr]
https://blog.csdn.net/sinat_31608641/article/details/107702175
std::weak_ptr 是一种智能指针，它对被 std::shared_ptr 管理的对象存在非拥有性（“弱”）引用,在访问所引用的对象前必须先转换为 std::shared_ptr
std::weak_ptr 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象。需要获得临时所有权时，则将其转换为 std::shared_ptr，此时如果原来的 std::shared_ptr 被销毁，则该对象的生命期将被延长至这个临时的 std::shared_ptr 同样被销毁为止。
方法：
     reset释放被管理的对象
     swap交换被管理的对象
     use_count返回管理该对象的shared_ptr的数量
     expired检查应用对象是否已删除
     lock创建管理被引用对象的shared_ptr(可以用来保证指针确实存在)
     owner_before

[std::string_view c++17]
比std::string高效：
std::string因为操作过程中，会重新分配内存，生成一个对应的std::string副本，用时1065ms，
std::string_view不持有字符串拷贝，与源字符串共享内存空间，其他是视图，避免了std::string频繁的字符串分配和拷贝操作，只用了85ms，效率显而易见。

     
     
